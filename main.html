<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CYBER VISUALIZER V10.0 - FINAL GESTURE CONTROL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        * { box-sizing: border-box; -webkit-font-smoothing: antialiased; }
        
        body { 
            margin: 0; overflow: hidden; 
            background-color: #000; 
            font-family: 'Share Tech Mono', monospace; 
            color: #00f3ff; 
        }
        
        /* 背景网格 */
        body::before {
            content: ""; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(rgba(0, 243, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: 0; pointer-events: none;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; transition: opacity 0.5s; }

        /* 装饰性框架 */
        .frame-deco { position: absolute; border: 1px solid rgba(0,243,255,0.3); pointer-events: none; }
        .frame-top-bar { top: 10px; left: 10px; right: 10px; height: 1px; background: linear-gradient(90deg, transparent, #00f3ff, transparent); opacity: 0.5; }
        .frame-btm-bar { bottom: 10px; left: 10px; right: 10px; height: 1px; background: linear-gradient(90deg, transparent, #ff0055, transparent); opacity: 0.5; }
        .corner-bracket { position: absolute; width: 40px; height: 40px; border: 2px solid #00f3ff; opacity: 0.6; }
        .cb-tl { top: 20px; left: 20px; border-right: none; border-bottom: none; }
        .cb-tr { top: 20px; right: 20px; border-left: none; border-bottom: none; }
        .cb-bl { bottom: 20px; left: 20px; border-right: none; border-top: none; border-color: #ff0055; }
        .cb-br { bottom: 20px; right: 20px; border-left: none; border-top: none; border-color: #ff0055; }

        /* 面板样式 */
        .hud-panel {
            background: rgba(0, 10, 20, 0.85); 
            border: 1px solid rgba(0, 243, 255, 0.4);
            backdrop-filter: blur(8px);
            padding: 20px; 
            position: absolute; 
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.15);
            transform-origin: top left;
        }

        .header-box { top: 30px; left: 50px; border-left: 6px solid #00f3ff; clip-path: polygon(0 0, 100% 0, 100% 85%, 95% 100%, 0 100%); }
        h1 { margin: 0; font-size: 2.5rem; letter-spacing: 5px; color: #fff; text-shadow: 0 0 15px #00f3ff; }
        .sub-header { font-size: 0.9rem; color: rgba(255,255,255,0.7); letter-spacing: 2px; }
        
        .mode-box { top: 30px; right: 50px; text-align: right; border-right: 6px solid #d000ff; clip-path: polygon(10% 0, 100% 0, 100% 100%, 0 100%, 0 15%); }
        #mode-display { font-size: 2.5rem; color: #d000ff; text-shadow: 0 0 20px #d000ff; font-weight: bold; }

        .radar-panel {
            top: 15%; left: 5%; width: 200px; height: 200px;
            border-radius: 50%; border: 2px solid #00f3ff;
            background: rgba(0, 20, 40, 0.5);
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; padding: 0;
        }
        .radar-scan {
            position: absolute; width: 100%; height: 100%; border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 300deg, rgba(0, 243, 255, 0.5) 360deg);
            animation: radar-spin 2s linear infinite;
        }
        .radar-grid { position: absolute; width: 100%; height: 100%; border-radius: 50%; background: radial-gradient(transparent 30%, rgba(0,243,255,0.2) 31%, transparent 32%), radial-gradient(transparent 60%, rgba(0,243,255,0.2) 61%, transparent 62%); }
        .radar-grid::after { content: ''; position: absolute; width: 100%; height: 1px; top: 50%; background: rgba(0,243,255,0.2); }
        .radar-grid::before { content: ''; position: absolute; height: 100%; width: 1px; left: 50%; background: rgba(0,243,255,0.2); }
        .radar-dot { position: absolute; width: 6px; height: 6px; background: #ff0055; border-radius: 50%; box-shadow: 0 0 8px #ff0055; opacity: 0; animation: blink-dot 2s infinite; }
        @keyframes radar-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes blink-dot { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }

        .energy-panel {
            top: 40%; left: 95%; width: 60px; height: 300px;
            display: flex; flex-direction: column-reverse;
            background: rgba(0,0,0,0.6); border: 1px solid #00f3ff; padding: 5px;
        }
        .e-label { position: absolute; top: -25px; left: 0; width: 100%; text-align: center; font-size: 0.7rem; color: #00f3ff; }
        .e-bar-container { width: 100%; height: 100%; position: relative; overflow: hidden; }
        .e-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background: repeating-linear-gradient(0deg, #00f3ff, #00f3ff 4px, transparent 4px, transparent 8px); box-shadow: 0 0 10px #00f3ff; transition: height 0.5s; }

        .term-panel {
            top: 25%; left: 2%; width: 320px; height: 250px;
            font-size: 0.75rem; overflow: hidden;
            display: flex; flex-direction: column; justify-content: flex-end;
            border-left: 2px dashed #00f3ff; background: rgba(0,0,0,0.8);
        }
        .term-title { background: #00f3ff; color: #000; padding: 2px 5px; font-weight: bold; margin-bottom: 5px; }
        #term-log { height: 100%; display: flex; flex-direction: column; justify-content: flex-end; color: rgba(0,243,255,0.8); line-height: 1.4; }
        .log-line span { color: #fff; }

        .sys-panel { top: 60%; left: 2%; width: 380px; border-top: 2px solid rgba(0,243,255,0.6); clip-path: polygon(0 15%, 5% 0, 100% 0, 100% 100%, 0 100%); }
        .panel-title { font-size: 1.1rem; color: #ff0055; letter-spacing: 3px; margin-bottom: 10px; border-bottom: 1px dashed rgba(255,0,85,0.5); padding-bottom: 5px; }
        .gauges-row { display: flex; justify-content: space-around; margin: 15px 0; }
        .gauge-wrap { position: relative; width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; }
        .gauge-svg { width: 100%; height: 100%; transform: rotate(-90deg); }
        .gauge-bg { fill: none; stroke: rgba(0,243,255,0.2); stroke-width: 3; }
        .gauge-val { fill: none; stroke: #00f3ff; stroke-width: 3; stroke-dasharray: 100; stroke-dashoffset: 30; transition: stroke-dashoffset 0.5s ease; filter: drop-shadow(0 0 2px #00f3ff); }
        .gauge-num { position: absolute; font-size: 0.8rem; font-weight: bold; color: #fff; }
        .stat-row { display: flex; justify-content: space-between; font-size: 1rem; margin-bottom: 5px; color: rgba(255,255,255,0.9); }
        .stat-val { color: #00f3ff; font-weight: bold; } .stat-bar { width: 100%; height: 6px; background: rgba(0,243,255,0.15); margin-top: 4px; } .stat-fill { height: 100%; background: #00f3ff; width: 0%; box-shadow: 0 0 10px #00f3ff; }

        .core-panel {
            top: 30%; left: 78%;
            width: 220px; height: 220px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: transparent; border: none; box-shadow: none; backdrop-filter: none;
        }
        .reactor-container { width: 120px; height: 120px; position: relative; transform-style: preserve-3d; animation: spin-core 10s linear infinite; }
        .reactor-ring { position: absolute; border-radius: 50%; border: 2px solid #ff0055; box-shadow: 0 0 15px #ff0055; opacity: 0.8; }
        .r1 { width: 100%; height: 100%; transform: rotateX(0deg); border-left: 2px solid transparent; border-right: 2px solid transparent; }
        .r2 { width: 80%; height: 80%; top: 10%; left: 10%; transform: rotateX(60deg); border-top: 2px solid transparent; border-bottom: 2px solid transparent; border-color: #00f3ff; box-shadow: 0 0 15px #00f3ff; }
        .r3 { width: 60%; height: 60%; top: 20%; left: 20%; transform: rotateY(60deg); border-color: #fff; }
        .core-label { margin-top: 20px; font-size: 0.8rem; color: #ff0055; letter-spacing: 3px; text-align: center; background: rgba(0,0,0,0.6); padding: 5px; border: 1px solid #ff0055; }
        @keyframes spin-core { 0% { transform: rotateY(0deg) rotateX(0deg); } 100% { transform: rotateY(360deg) rotateX(360deg); } }

        .audio-panel { top: 70%; left: 78%; width: 340px; text-align: right; clip-path: polygon(0 0, 100% 0, 100% 85%, 95% 100%, 0 100%); border-right: 3px solid #00f3ff; }
        .audio-bars { display: flex; gap: 6px; height: 80px; align-items: flex-end; justify-content: flex-end; margin-top: 15px; }
        .a-bar { width: 12px; background: rgba(255,255,255,0.05); height: 100%; position: relative; }
        .a-fill { position: absolute; bottom: 0; left: 0; width: 100%; background: linear-gradient(to top, #00f3ff, #d000ff); }
        .vol-text { font-size: 4rem; font-weight: bold; color: rgba(255,255,255,0.1); position: absolute; bottom: 15px; right: 140px; z-index: -1; }

        #cam-container { position: absolute; top: 50%; left: 50%; width: 240px; height: 160px; background: #000; border: 1px solid rgba(0,243,255,0.4); box-shadow: 0 0 20px rgba(0,243,255,0.1); overflow: hidden; opacity: 0; transform: translate(-50%, -50%); z-index: 20; pointer-events: auto; }
        #webcam-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); filter: contrast(1.2) brightness(1.1) sepia(100%) hue-rotate(130deg) saturate(1.5); opacity: 0.8; }
        .scanlines { position: absolute; top:0; left:0; width:100%; height:100%; background: linear-gradient(to bottom, rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%); background-size: 100% 4px; pointer-events: none; z-index: 5; }
        .reticle { width: 40px; height: 40px; border: 1px solid rgba(255,0,85,0.6); position: relative; box-shadow: 0 0 10px rgba(255,0,85,0.3); transition: transform 0.2s, border-color 0.2s; }
        .cam-ui { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 6; display: flex; justify-content: center; align-items: center; border: 1px solid rgba(0,243,255,0.3); }
        #cam-status-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, 30px); font-size: 10px; color: #fff; text-shadow: 0 0 5px #ff0055; z-index: 7; text-align: center; width: 100%; }
        #gesture-alert { position: absolute; top: 10px; left: 0; width: 100%; text-align: center; font-weight: bold; font-size: 14px; color: #00f3ff; display: none; text-shadow: 0 0 5px #00f3ff; }
        #control-mode-text { position: absolute; bottom: 10px; left: 0; width: 100%; text-align: center; color: #00ff00; font-weight: bold; font-size: 12px; display: none; text-shadow: 0 0 5px #00ff00; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <div class="frame-deco frame-top-bar"></div>
        <div class="frame-deco frame-btm-bar"></div>
        <div class="frame-deco corner-bracket cb-tl"></div>
        <div class="frame-deco corner-bracket cb-tr"></div>
        <div class="frame-deco corner-bracket cb-bl"></div>
        <div class="frame-deco corner-bracket cb-br"></div>

        <div class="hud-panel header-box" id="main-hud">
            <h1>BORAN <span>SYS</span></h1>
            <div class="sub-header">KERNEL: 10.0-FINAL // SECURE</div>
            <div class="sub-header" id="date-display" style="color: #ff0055">2077-01-01</div>
        </div>
        
        <div class="hud-panel mode-box">
            <div class="mode-label">GEOMETRY PROTOCOL</div>
            <div id="mode-display">WORMHOLE</div>
            <div style="font-size: 0.8rem; color: #00f3ff; margin-top: 5px;">SYNC_RATE: 100%</div>
        </div>

        <div class="hud-panel radar-panel">
            <div class="radar-scan"></div>
            <div class="radar-grid"></div>
        </div>

        <div class="hud-panel energy-panel">
            <div class="e-label">POWER</div>
            <div class="e-bar-container">
                <div class="e-fill"></div>
            </div>
        </div>

        <div class="hud-panel term-panel">
            <div class="term-title">/// SYS_LOG.TXT</div>
            <div id="term-log">
                <div class="log-line"><span>> INIT...</span> SYSTEM_READY</div>
            </div>
        </div>

        <div class="hud-panel core-panel">
            <div class="reactor-container">
                <div class="reactor-ring r1"></div>
                <div class="reactor-ring r2"></div>
                <div class="reactor-ring r3"></div>
            </div>
            <div class="core-label">REACTOR ONLINE<br><span style="font-size:0.6rem; color:#fff;">STABLE</span></div>
        </div>

        <div id="cam-container">
            <div class="scanlines"></div>
            <div class="cam-ui"><div class="reticle"></div></div>
            <div id="gesture-alert">SWIPE DETECTED</div>
            <div id="cam-status-text">INIT...</div>
            <div id="control-mode-text">/// MANUAL OVERRIDE ///</div>
            <video id="webcam-video" autoplay playsinline muted></video>
        </div>

        <div class="hud-panel sys-panel">
            <div class="panel-title">/// SYS_DIAGNOSTICS</div>
            <div class="gauges-row">
                <div class="gauge-wrap">
                    <svg class="gauge-svg" viewBox="0 0 36 36">
                        <path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                        <path class="gauge-val" id="cpu-gauge" stroke-dasharray="100, 100" stroke-dashoffset="50" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    </svg>
                    <div class="gauge-num" id="cpu-num">45%</div>
                </div>
                <div class="gauge-wrap">
                    <svg class="gauge-svg" viewBox="0 0 36 36">
                        <path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                        <path class="gauge-val" id="ram-gauge" stroke-dasharray="100, 100" stroke-dashoffset="20" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    </svg>
                    <div class="gauge-num" id="ram-num">80%</div>
                </div>
                <div class="gauge-wrap">
                    <svg class="gauge-svg" viewBox="0 0 36 36">
                        <path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                        <path class="gauge-val" id="net-gauge" stroke-dasharray="100, 100" stroke-dashoffset="80" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    </svg>
                    <div class="gauge-num" id="net-num">12ms</div>
                </div>
            </div>
            <div class="stat-row"><span>FRAMERATE</span><span id="fps-val" class="stat-val">60 FPS</span></div>
            <div class="stat-bar"><div class="stat-fill" id="fps-bar" style="width: 100%"></div></div>
            <div class="stat-row" style="margin-top: 10px;"><span>PARTICLES</span><span id="particle-val" class="stat-val">45K</span></div>
        </div>

        <div class="hud-panel audio-panel">
            <div class="panel-title">/// AUDIO_SPECTRA</div>
            <div class="vol-text" id="vol-big">00</div>
            <div class="stat-row"><span>OUTPUT_GAIN</span><span id="gain-val" class="stat-val">0 DB</span></div>
            <div class="audio-bars" id="audio-viz">
                <div class="a-bar"><div class="a-fill" style="height:20%"></div></div><div class="a-bar"><div class="a-fill" style="height:40%"></div></div><div class="a-bar"><div class="a-fill" style="height:60%"></div></div><div class="a-bar"><div class="a-fill" style="height:30%"></div></div><div class="a-bar"><div class="a-fill" style="height:10%"></div></div><div class="a-bar"><div class="a-fill" style="height:50%"></div></div><div class="a-bar"><div class="a-fill" style="height:80%"></div></div><div class="a-bar"><div class="a-fill" style="height:40%"></div></div><div class="a-bar"><div class="a-fill" style="height:20%"></div></div><div class="a-bar"><div class="a-fill" style="height:10%"></div></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const config = {
            count: 45000, 
            baseSize: 2.5,
            color: new THREE.Color('#00f3ff'),
            secondaryColor: new THREE.Color('#d000ff'),
            audioSens: 2.0,
            bloomStr: 1.5,
            rotSpeed: 0.5,
            mouseParallax: 1.5,
            useWebcam: false,
            mode: 0,
            colorMode: 3, 
            swipeEnabled: true,
            isPinched: false,
            handX: 0.5, 
            handY: 0.5,
            // 新增灵敏度配置
            zoomSens: 1.0, 
            pinchSens: 1.0
        };

        const modeNames = [
            "WORMHOLE", "SUPERNOVA", "ACCRETION DISK", "CYBER GRID", "STARGATE", 
            "NEBULA KNOT", "BIG BANG", "LORENZ", "QUASAR", 
            "SATURN RING", "CYBER HEART", "GALAXY SPIRAL", "TORNADO SPIRAL"
        ];

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0007);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 15000);
        camera.position.set(0, 100, 1600);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setClearColor(0x000000, 1);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const afterimagePass = new AfterimagePass();
        afterimagePass.uniforms["damp"].value = 0.85; 
        composer.addPass(afterimagePass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const geometry = new THREE.BufferGeometry();
        const posArr = new Float32Array(config.count * 3);
        const targetArr = new Float32Array(config.count * 3);
        const colArr = new Float32Array(config.count * 3);
        const sizeArr = new Float32Array(config.count);

        const shapes = {}; 
        function rand(min, max) { return Math.random() * (max - min) + min; }

        function initShapes() {
            for(let k=0; k<modeNames.length; k++) shapes[k] = [];

            for(let i=0; i<config.count; i++) {
                const t = i/config.count; const a = t * Math.PI * 40; const r = 200 + Math.pow(Math.abs(t-0.5)*2, 2)*1200;
                shapes[0].push(Math.cos(a)*r+rand(-50,50), Math.sin(a)*r+rand(-50,50), (t-0.5)*4000);
            }
            for(let i=0; i<config.count; i++) {
                const th = Math.random()*Math.PI*2; const ph = Math.acos((Math.random()*2)-1); const r = 20 + Math.pow(Math.random(), 3) * 2000;
                shapes[1].push(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));
            }
            for(let i=0; i<config.count; i++) {
                const a = Math.random()*Math.PI*2; 
                if(Math.random()>0.85) { const r = Math.random()*300; const p = Math.acos((Math.random()*2)-1); shapes[2].push(r*Math.sin(p)*Math.cos(a), r*Math.sin(p)*Math.sin(a), r*Math.cos(p)); } 
                else { let r = 400 + Math.random()*1000; shapes[2].push(r*Math.cos(a), (Math.random()-0.5)*50*(1500/r), r*Math.sin(a)); }
            }
            for(let i=0; i<config.count; i++) {
                const gs = 80; const x = rand(-1500, 1500); const z = rand(-1500, 1500); const gx = Math.round(x/gs)*gs; const gz = Math.round(z/gs)*gs;
                shapes[3].push(gx, Math.sin(gx*0.003)*Math.cos(gz*0.003)*400 + rand(-10,10), gz);
            }
            for(let i=0; i<config.count; i++) {
                const u = i/config.count * Math.PI*2; const r = 900 + 200*Math.cos(8*u); shapes[4].push(r*Math.cos(3*u), r*Math.sin(3*u), 300*Math.sin(8*u) + rand(-80,80));
            }
            for(let i=0; i<config.count; i++) {
                const t = (i/config.count)*Math.PI*120; const s = 700; shapes[5].push(s*(Math.cos(t)+Math.cos(3*t))*0.5+rand(-100,100), s*(Math.sin(t)+Math.sin(3*t))*0.5+rand(-100,100), s*Math.sin(4*t)*0.5+rand(-100,100));
            }
            for(let i=0; i<config.count; i++) {
                const th = Math.random()*Math.PI*2; const ph = Math.acos((Math.random()*2)-1); const r = (Math.exp(Math.random()*4.5)-1) * 35; shapes[6].push(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));
            }
            let lx=0.1, ly=0, lz=0; const dt=0.003;
            for(let i=0; i<config.count; i++) {
                let dx = 10*(ly-lx)*dt; let dy = (lx*(28-lz)-ly)*dt; let dz = (lx*ly-(8/3)*lz)*dt; lx+=dx; ly+=dy; lz+=dz; shapes[7].push(lx*35, ly*35, (lz-25)*35);
            }
            for(let i=0; i<config.count; i++) {
                if (Math.random() < 0.25) { const r = Math.random() * 250; const th = Math.random()*Math.PI*2; const ph = Math.acos((Math.random()*2)-1); shapes[8].push(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph)); } 
                else { const y = (Math.random()-0.5) * 4500; const spread = 20 + Math.abs(y)*0.12; shapes[8].push(rand(-spread,spread), y, rand(-spread,spread)); }
            }
            for(let i=0; i<config.count; i++) {
                if (Math.random() > 0.3) {
                    const r = 250; const th = Math.random()*Math.PI*2; const ph = Math.acos((Math.random()*2)-1); shapes[9].push(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));
                } else {
                    const r = 400 + Math.random()*400; const a = Math.random()*Math.PI*2; shapes[9].push(r*Math.cos(a), rand(-10,10), r*Math.sin(a));
                }
            }
            for(let i=0; i<config.count; i++) {
                const t = Math.random() * Math.PI * 2; const p = Math.random() * Math.PI;
                const x = 16 * Math.pow(Math.sin(p), 3) * Math.cos(t);
                const y = 13 * Math.cos(p) - 5 * Math.cos(2*p) - 2 * Math.cos(3*p) - Math.cos(4*p);
                const z = 16 * Math.pow(Math.sin(p), 3) * Math.sin(t);
                const s = 30; shapes[10].push(x*s + rand(-20,20), y*s + rand(-20,20), z*s + rand(-20,20));
            }
            for(let i=0; i<config.count; i++) {
                const arms = 5; const armOffset = (Math.floor(Math.random()*arms)/arms) * Math.PI*2;
                const dist = Math.random(); const r = Math.pow(dist, 2) * 1200; const angle = dist * 10 + armOffset;
                shapes[11].push(r*Math.cos(angle) + rand(-100,100), (Math.random()-0.5)*200*(1-dist), r*Math.sin(angle) + rand(-100,100));
            }
            // Tornado Spiral
            for(let i=0; i<config.count; i++) {
                const t = i / config.count;
                const h = (t - 0.5) * 1600; 
                const r = 50 + t * 600; 
                const twist = t * Math.PI * 12; 
                const armOffset = (i % 3) * (Math.PI * 2 / 3); 
                const angle = twist + armOffset + rand(-0.3, 0.3); 
                shapes[12].push(r * Math.cos(angle), h, r * Math.sin(angle));
            }
        }
        initShapes();

        for(let i=0; i<config.count*3; i++) { posArr[i] = shapes[0][i]; targetArr[i] = shapes[0][i]; colArr[i] = i/config.count; }
        for(let i=0; i<config.count; i++) sizeArr[i] = Math.random();
        geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geometry.setAttribute('colorAttr', new THREE.BufferAttribute(colArr, 1));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));

        const uniforms = {
            uTime: { value: 0 },
            uBass: { value: 0 }, uMid: { value: 0 }, uHigh: { value: 0 },
            uInteractPos: { value: new THREE.Vector3(0,0,0) },
            uInteractStr: { value: 0 }, 
            uMode: { value: 0 },
            uColor: { value: config.color }, 
            uSecColor: { value: config.secondaryColor },
            uSize: { value: config.baseSize },
            uColorMode: { value: config.colorMode }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
                uniform float uTime;
                uniform float uBass; uniform float uMid; uniform float uHigh;
                uniform vec3 uInteractPos; uniform float uInteractStr; uniform float uMode; uniform float uSize;
                attribute float size; attribute float colorAttr; 
                varying float vType; varying float vIntensity; varying vec3 vPos;
                void main() {
                    vType = colorAttr; vec3 pos = position; vPos = pos;
                    float iB = 1.0-step(0.33, colorAttr); float iH = step(0.66, colorAttr); float iM = 1.0-iB-iH;
                    vec3 dir = normalize(pos);
                    vec3 mB = dir * uBass * 100.0;
                    float sw = uMid * length(pos)*0.0006;
                    vec3 mM = (vec3(pos.x*cos(sw)-pos.z*sin(sw), pos.y, pos.x*sin(sw)+pos.z*cos(sw)) - pos) * iM;
                    vec3 mH = dir * sin(uTime*15.0+pos.x*0.05) * uHigh * 25.0;
                    float dist = distance(pos.xy, uInteractPos.xy);
                    vec3 mInt = vec3(0.0);
                    if (uMode < 0.5) { 
                        float repel = smoothstep(800.0, 0.0, dist) * 300.0 * uInteractStr;
                        mInt = dir * repel; 
                    } else { pos *= (0.6 + uInteractStr * 1.4); }
                    pos += mB + mM + mH + mInt;
                    vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPos;
                    float beat = 1.0 + iB*uBass*0.7 + iH*uHigh*0.7;
                    gl_PointSize = (uSize * size * beat * 3.0) * (400.0 / -mvPos.z);
                    vIntensity = iB*uBass + iM*uMid + iH*uHigh;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor; uniform vec3 uSecColor; uniform float uColorMode; uniform float uTime;
                varying float vType; varying float vIntensity; varying vec3 vPos;
                vec3 hsl2rgb( in vec3 c ) {
                    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
                    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
                }
                void main() {
                    if(dot(gl_PointCoord-0.5, gl_PointCoord-0.5)>0.25) discard;
                    vec3 finalCol = uColor;
                    if (uColorMode < 0.5) { finalCol = uColor + vec3(vIntensity*0.5); }
                    else if (uColorMode < 1.5) { finalCol = mix(uColor, uSecColor, vType + vIntensity*0.2); }
                    else if (uColorMode < 2.5) { float hue = fract(length(vPos) * 0.001 - uTime * 0.1); finalCol = hsl2rgb(vec3(hue, 0.8, 0.6)); finalCol += vec3(vIntensity * 0.5); }
                    else {
                        vec3 c1 = vec3(0.0, 0.95, 1.0); vec3 c2 = vec3(1.0, 0.0, 0.33); vec3 c3 = vec3(0.8, 0.0, 1.0);
                        float t = fract(vType * 3.0 + uTime * 0.2);
                        if(t < 0.33) finalCol = mix(c1, c2, t*3.0);
                        else if(t < 0.66) finalCol = mix(c2, c3, (t-0.33)*3.0);
                        else finalCol = mix(c3, c1, (t-0.66)*3.0);
                        finalCol += vec3(vIntensity);
                    }
                    gl_FragColor = vec4(finalCol, 0.9);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        scene.add(new THREE.Points(geometry, material));

        let handLandmarker; let video = document.getElementById('webcam-video');
        let stream = null; let lastVidTime = -1; let visionLoaded = false;
        let lastHandX = -1; let swipeCooldown = 0;

        async function initVision() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                visionLoaded = true;
            } catch(e) {}
        }
        initVision();

        async function toggleWebcam(enable) {
            const container = document.getElementById('cam-container');
            const statusText = document.getElementById('cam-status-text');
            if (enable) {
                container.style.opacity = 1; statusText.innerText = "CONNECTING...";
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                    video.srcObject = stream;
                    video.onloadeddata = () => { statusText.innerText = "SCANNING"; statusText.style.color = "#00f3ff"; predictLoop(); };
                    uniforms.uMode.value = 1.0;
                } catch(e) { statusText.innerText = "ACCESS DENIED"; statusText.style.color = "red"; }
            } else {
                container.style.opacity = 0; 
                if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
                uniforms.uMode.value = 0.0;
            }
        }

        function switchMode(dir) {
            let newMode = config.mode + dir;
            if(newMode >= modeNames.length) newMode = 0;
            if(newMode < 0) newMode = modeNames.length - 1;
            config.mode = newMode;
            document.getElementById('mode-display').innerText = modeNames[newMode];
            const arr = shapes[newMode] || shapes[0];
            for(let i=0; i<config.count*3; i++) targetArr[i] = arr[i];
            
            const alert = document.getElementById('gesture-alert');
            alert.innerText = `SWITICHING: ${modeNames[newMode]}`;
            alert.style.display = 'block';
            setTimeout(() => alert.style.display = 'none', 1500);
        }

        async function predictLoop() {
            if (!config.useWebcam || !stream) return;
            if (visionLoaded && handLandmarker && video.currentTime !== lastVidTime) {
                lastVidTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                const statusText = document.getElementById('cam-status-text');
                const reticle = document.querySelector('.reticle');
                const controlText = document.getElementById('control-mode-text');
                
                if (result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    
                    // 1. 手势缩放 (应用 Zoom Sensitivity)
                    let dist = 0; [lm[4], lm[8], lm[12], lm[16], lm[20]].forEach(t => dist += Math.sqrt(Math.pow(t.x-lm[0].x,2) + Math.pow(t.y-lm[0].y,2)));
                    let scale = (dist/5 - 0.1) * (3.5 * config.zoomSens); // 默认系数3.5 * 灵敏度
                    
                    // 2. 捏合检测
                    const pinchDist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    
                    if (pinchDist < 0.06) { 
                        config.isPinched = true;
                        config.handX = lm[9].x; 
                        config.handY = lm[9].y;
                        
                        statusText.innerText = "MANUAL CONTROL"; statusText.style.color = "#00ff00";
                        controlText.style.display = "block";
                        reticle.style.borderColor = "#00ff00";
                        reticle.style.transform = "scale(0.8)";
                        
                        uniforms.uInteractStr.value += (0 - uniforms.uInteractStr.value) * 0.1;
                    } else {
                        config.isPinched = false;
                        statusText.innerText = "TARGET LOCKED"; statusText.style.color = "#ff0055";
                        controlText.style.display = "none";
                        reticle.style.borderColor = "#ff0055"; 
                        reticle.style.transform = "rotate(45deg)";
                        
                        uniforms.uInteractStr.value += (scale - uniforms.uInteractStr.value) * 0.15;
                    }

                    // 3. 挥手逻辑
                    const currX = lm[0].x;
                    const now = performance.now();
                    if (config.swipeEnabled && lastHandX !== -1 && now > swipeCooldown && !config.isPinched) { 
                        const delta = currX - lastHandX;
                        if (Math.abs(delta) > 0.05) { 
                            if (delta < 0) switchMode(1);
                            else switchMode(-1);
                            swipeCooldown = now + 1000;
                        }
                    }
                    lastHandX = currX;

                } else {
                    uniforms.uInteractStr.value += (1.0 - uniforms.uInteractStr.value) * 0.05;
                    statusText.innerText = "SEARCHING..."; statusText.style.color = "#00f3ff";
                    controlText.style.display = "none";
                    reticle.style.borderColor = "rgba(0,243,255,0.6)"; reticle.style.transform = "rotate(0deg)";
                    lastHandX = -1;
                    config.isPinched = false; 
                }
            }
            requestAnimationFrame(predictLoop);
        }

        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
            if(!config.useWebcam) { uniforms.uInteractPos.value.set(mouse.x*800, mouse.y*800, 0); uniforms.uInteractStr.value=1.0; }
        });

        const uiElems = {
            sysPanel: document.querySelector('.sys-panel'), audioPanel: document.querySelector('.audio-panel'),
            termPanel: document.querySelector('.term-panel'), corePanel: document.querySelector('.core-panel'),
            radarPanel: document.querySelector('.radar-panel'), energyPanel: document.querySelector('.energy-panel'),
            energyFill: document.querySelector('.e-fill'), radarGrid: document.querySelector('.radar-grid'),
            fpsVal: document.getElementById('fps-val'), fpsBar: document.getElementById('fps-bar'), 
            dateVal: document.getElementById('date-display'), gainVal: document.getElementById('gain-val'), 
            volBig: document.getElementById('vol-big'), bars: document.querySelectorAll('.a-fill'), 
            termLog: document.getElementById('term-log'), 
            cpuGauge: document.getElementById('cpu-gauge'), cpuNum: document.getElementById('cpu-num'), 
            ramGauge: document.getElementById('ram-gauge'), ramNum: document.getElementById('ram-num'), 
            netGauge: document.getElementById('net-gauge'), netNum: document.getElementById('net-num')
        };

        function updateRadar() { if (Math.random() < 0.05) { const dot = document.createElement('div'); dot.className = 'radar-dot'; const ang = Math.random() * Math.PI * 2; const dist = Math.random() * 45; dot.style.left = (50 + Math.cos(ang)*dist) + '%'; dot.style.top = (50 + Math.sin(ang)*dist) + '%'; uiElems.radarGrid.appendChild(dot); setTimeout(() => dot.remove(), 2000); } } setInterval(updateRadar, 100);
        function updateEnergy() { const h = 40 + Math.random() * 60; uiElems.energyFill.style.height = h + '%'; uiElems.energyFill.style.boxShadow = `0 0 ${h/5}px #00f3ff`; } setInterval(updateEnergy, 500);
        const termLines = ["CONNECTING...", "ENCRYPTING...", "OPTIMIZING KERNEL...", "HIGH CPU LOAD", "SCANNING HOSTILES...", "PING: 14ms", "SYNC COMPLETE", "LOADING SHADERS...", "BUFFER OVERFLOW", "TRACE ROUTE", "USER AUTH: OK", "RENDER ACTIVE", "AUDIO DETECTED", "ENERGY STABLE", "RADAR PING"];
        function addLogLine() { const line = termLines[Math.floor(Math.random() * termLines.length)]; const div = document.createElement('div'); div.className = "log-line"; div.innerHTML = `<span>> ${Math.floor(performance.now())}</span> ${line}`; uiElems.termLog.appendChild(div); if (uiElems.termLog.children.length > 8) uiElems.termLog.removeChild(uiElems.termLog.firstChild); } setInterval(addLogLine, 800);
        function updateGauges() { const cpu = Math.floor(30 + Math.random() * 40); uiElems.cpuNum.innerText = cpu + "%"; uiElems.cpuGauge.style.strokeDashoffset = 100 - cpu; const ram = Math.floor(50 + Math.random() * 30); uiElems.ramNum.innerText = ram + "%"; uiElems.ramGauge.style.strokeDashoffset = 100 - ram; const net = Math.floor(5 + Math.random() * 20); uiElems.netGauge.style.strokeDashoffset = 100 - net; } setInterval(updateGauges, 2000);
        function updateDate() { const d = new Date(); uiElems.dateVal.innerText = d.toISOString().split('T')[0] + " " + d.toTimeString().split(' ')[0]; } setInterval(updateDate, 1000); updateDate();

        window.wallpaperPropertyListener = {
            applyUserProperties: function(prop) {
                if (prop.schemecolor) { const c = prop.schemecolor.value.split(' ').map(parseFloat); config.color.setRGB(c[0], c[1], c[2]); uniforms.uColor.value = config.color; const cssCol = `rgb(${c[0]*255},${c[1]*255},${c[2]*255})`; document.getElementById('main-hud').style.borderColor = cssCol; document.querySelectorAll('.stat-fill').forEach(el=>el.style.backgroundColor=cssCol); document.querySelectorAll('.term-title').forEach(el=>el.style.backgroundColor=cssCol); }
                if (prop.secondary_color) { const c = prop.secondary_color.value.split(' ').map(parseFloat); config.secondaryColor.setRGB(c[0], c[1], c[2]); uniforms.uSecColor.value = config.secondaryColor; }
                if (prop.color_mode) { config.colorMode = parseInt(prop.color_mode.value); uniforms.uColorMode.value = config.colorMode; }
                if (prop.geometry_mode) { const idx = parseInt(prop.geometry_mode.value); config.mode = idx; document.getElementById('mode-display').innerText = modeNames[idx]; const arr = shapes[idx] || shapes[0]; for(let i=0; i<config.count*3; i++) targetArr[i] = arr[i]; }
                if (prop.particle_size) uniforms.uSize.value = prop.particle_size.value;
                if (prop.bloom_strength) bloomPass.strength = prop.bloom_strength.value;
                if (prop.trail_strength) afterimagePass.uniforms["damp"].value = prop.trail_strength.value;
                if (prop.rotation_speed) config.rotSpeed = prop.rotation_speed.value;
                if (prop.audio_sensitivity) config.audioSens = prop.audio_sensitivity.value;
                if (prop.mouse_parallax) config.mouseParallax = prop.mouse_parallax.value;
                if (prop.show_hud) document.getElementById('ui-layer').style.opacity = prop.show_hud.value ? 1 : 0;
                if (prop.use_webcam) { config.useWebcam = prop.use_webcam.value; toggleWebcam(config.useWebcam); }
                if (prop.enable_swipe) config.swipeEnabled = prop.enable_swipe.value;
                
                // 新增手势灵敏度
                if (prop.gesture_zoom_sens) config.zoomSens = prop.gesture_zoom_sens.value;
                if (prop.gesture_pinch_sens) config.pinchSens = prop.gesture_pinch_sens.value;

                if (prop.cam_pos_x) document.getElementById('cam-container').style.left = prop.cam_pos_x.value + '%';
                if (prop.cam_pos_y) document.getElementById('cam-container').style.top = prop.cam_pos_y.value + '%';
                if (prop.cam_scale) document.getElementById('cam-container').style.transform = `translate(-50%, -50%) scale(${prop.cam_scale.value})`;
                const panels = ['sys', 'audio', 'term', 'core', 'radar', 'energy'];
                panels.forEach(p => { if (prop[`${p}_pos_x`]) uiElems[`${p}Panel`].style.left = prop[`${p}_pos_x`].value + '%'; if (prop[`${p}_pos_y`]) uiElems[`${p}Panel`].style.top = prop[`${p}_pos_y`].value + '%'; if (prop[`${p}_scale`]) uiElems[`${p}Panel`].style.transform = `scale(${prop[`${p}_scale`].value})`; });
            }
        };

        let sB=0, sM=0, sH=0; let audioArr = new Array(10).fill(0);
        window.wallpaperRegisterAudioListener && window.wallpaperRegisterAudioListener((d) => {
            let b=0,m=0,h=0; for(let i=0;i<5;i++) b+=d[i]+d[i+64]; for(let i=5;i<20;i++) m+=d[i]+d[i+64]; for(let i=20;i<64;i++) h+=d[i]+d[i+64];
            b=(b/10)*config.audioSens; m=(m/30)*config.audioSens; h=(h/88)*config.audioSens*1.5;
            sB+=(b-sB)*0.2; sM+=(m-sM)*0.15; sH+=(h-sH)*0.15; uniforms.uBass.value=sB; uniforms.uMid.value=sM; uniforms.uHigh.value=sH;
            const totalVol = Math.min((sB+sM+sH)*30, 99); uiElems.volBig.innerText = Math.floor(totalVol).toString().padStart(2, '0'); uiElems.gainVal.innerText = `${(sB*10).toFixed(1)} DB`;
            for(let i=0; i<10; i++) { let val = d[i*4] + d[i*4+1] + d[i*4+64]; audioArr[i] += (val * config.audioSens * 0.5 - audioArr[i]) * 0.3; uiElems.bars[i].style.height = Math.min(audioArr[i] * 100, 100) + '%'; }
        });

        let lastTime = 0; let frames = 0;
        let camTheta = 0; let camPhi = Math.PI / 2;
        let camRadius = 1600;

        function animate(time) {
            requestAnimationFrame(animate); 
            const t = time * 0.001; 
            uniforms.uTime.value = t;
            if (time - lastTime >= 1000) { uiElems.fpsVal.innerText = `${frames} FPS`; uiElems.fpsBar.style.width = Math.min((frames/144)*100, 100) + '%'; frames = 0; lastTime = time; } frames++;
            
            const p = geometry.attributes.position.array; 
            for(let i=0; i<config.count*3; i++) p[i] += (targetArr[i] - p[i]) * 0.035; 
            geometry.attributes.position.needsUpdate = true;
            
            // --- 核心更新：摄像机逻辑 (应用 Pinch Rotate Sensitivity) ---
            if (config.useWebcam && config.isPinched) {
                // 手位置 (0-1) -> 偏移量 (-0.5 - 0.5) -> 乘以 灵敏度 -> 映射到角度
                const targetTheta = (1 - config.handX) * (Math.PI * 2 * config.pinchSens) + Math.PI; 
                const targetPhi = config.handY * (Math.PI * 0.8 * config.pinchSens) + 0.1;

                camTheta += (targetTheta - camTheta) * 0.1;
                camPhi += (targetPhi - camPhi) * 0.1;

            } else {
                const autoRot = t * config.rotSpeed * 0.15;
                camTheta = autoRot;
                camPhi += (Math.PI/2 - camPhi) * 0.05; 
                
                if (!config.useWebcam && config.mouseParallax > 0) { 
                    camTheta += mouse.x * config.mouseParallax * 0.5;
                    camPhi = Math.PI/2 - mouse.y * 0.5 * config.mouseParallax;
                }
            }

            camera.position.x = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
            camera.position.y = camRadius * Math.cos(camPhi);
            camera.position.z = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
            camera.lookAt(0,0,0);
            
            composer.render();
        }
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
        animate(0);
    </script>
</body>
</html>